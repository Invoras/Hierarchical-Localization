<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaussian Splat Viewer</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #1a1a2e; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 100;
            pointer-events: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            text-align: center;
            z-index: 100;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        #loading .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #333;
            border-top-color: #00ff88;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">Loading Gaussian Splats...</div>
    </div>
    <div id="info">Initializing...</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "@mkkellogg/gaussian-splats-3d": "https://cdn.jsdelivr.net/npm/@mkkellogg/gaussian-splats-3d@0.4.2/build/gaussian-splats-3d.module.js"
        }
    }
    </script>

    <script>
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            const loadingText = document.getElementById('loading-text');
            if (loadingText) {
                loadingText.textContent = "Error: " + msg;
                loadingText.style.color = "#ff6b6b";
            }
            return false;
        };
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as GaussianSplats3D from '@mkkellogg/gaussian-splats-3d';

        const SPLAT_PATH = '/splat/point_cloud.ply';
        const DRONE_API = '/api/drone_position';
        const UPDATE_INTERVAL = 100; // ms

        // Globals
        let viewer;
        let droneGroup;
        let droneFrustumLines;
        let droneFrustumMesh;
        let cameraMode = 'auto'; // 'auto' or 'manual'
        let dronePosition = null;
        let droneRotation = null;
        let droneSource = null;
        let numSplats = 0;

        // Auto-follow parameters
        const CAMERA_OFFSET_BACK = 3.5;
        const CAMERA_OFFSET_UP = 1.5;
        const CAMERA_LERP_SPEED = 0.1;

        async function init() {
            // Initialize the viewer
            viewer = new GaussianSplats3D.Viewer({
                'cameraUp': [0, 1, 0], // Y-up
                'initialCameraPosition': [0, 2, 5],
                'initialCameraLookAt': [0, 0, 0],
                'sphericalHarmonicsDegree': 0, // Set to 0 to fix green tint (use only DC component)
                'gpuAcceleratedSort': true,
                'sharedMemoryForWorkers': false // Disable for compatibility
            });

            // Load the scene
            try {
                // We apply the 180 degree rotation around Z to the splat scene to match previous viewer
                // Quaternion for 180 deg around Z: [0, 0, 1, 0]
                await viewer.addSplatScene(SPLAT_PATH, {
                    'rotation': [0, 0, 1, 0],
                    'showLoadingUI': false,
                    'splatAlphaRemovalThreshold': 5,
                    'onProgress': (percent, percentLabel, chunkLabel) => {
                        document.getElementById('loading-text').textContent = `Loading Gaussian Splats... ${percent}%`;
                    }
                });
                
                document.getElementById('loading').style.opacity = 0;
                setTimeout(() => document.getElementById('loading').style.display = 'none', 500);
                
                // Setup Drone Visualization
                setupDroneViz();

                // Start the viewer
                viewer.start();

                // Start polling
                setInterval(updateDronePosition, UPDATE_INTERVAL);
                
                // Start animation loop for smooth camera/drone updates
                requestAnimationFrame(animate);

                // Listen for messages
                window.addEventListener('message', handleMessage);

            } catch (error) {
                console.error("Failed to load splats:", error);
                document.getElementById('loading-text').textContent = "Error loading splats: " + error.message;
                document.getElementById('loading-text').style.color = "#ff6b6b";
            }
        }

        function setupDroneViz() {
            // Create a group for the drone
            droneGroup = new THREE.Group();
            
            // Access the Three.js scene from the viewer
            // The viewer exposes 'threeScene' in recent versions, or we can find it
            if (viewer.threeScene) {
                viewer.threeScene.add(droneGroup);
            } else if (viewer.scene) {
                viewer.scene.add(droneGroup);
            } else {
                console.error("Could not find Three.js scene in viewer");
                return;
            }

            // Create Frustum Geometry
            // Frustum shape: pyramid with base at front
            const depth = 0.5; // meters
            const aspect = 16/9;
            const fovScale = 0.4;
            const halfW = depth * fovScale * aspect;
            const halfH = depth * fovScale;

            // Vertices
            const vertices = [
                0, 0, 0,          // 0: Center (Camera pos)
                -halfW, halfH, depth,  // 1: TL
                halfW, halfH, depth,   // 2: TR
                halfW, -halfH, depth,  // 3: BR
                -halfW, -halfH, depth  // 4: BL
            ];

            // Indices for lines
            const indices = [
                0, 1, 0, 2, 0, 3, 0, 4, // Center to corners
                1, 2, 2, 3, 3, 4, 4, 1  // Base rectangle
            ];

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setIndex(indices);

            // Line Material
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff88, linewidth: 2 });
            droneFrustumLines = new THREE.LineSegments(geometry, lineMaterial);
            droneGroup.add(droneFrustumLines);

            // Mesh for fill (base of pyramid)
            const meshGeometry = new THREE.BufferGeometry();
            // Two triangles for the base
            const meshVertices = [
                -halfW, halfH, depth, // TL
                halfW, halfH, depth,  // TR
                -halfW, -halfH, depth, // BL
                
                halfW, halfH, depth,  // TR
                halfW, -halfH, depth, // BR
                -halfW, -halfH, depth // BL
            ];
            meshGeometry.setAttribute('position', new THREE.Float32BufferAttribute(meshVertices, 3));
            
            const meshMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff88, 
                transparent: true, 
                opacity: 0.3, 
                side: THREE.DoubleSide 
            });
            droneFrustumMesh = new THREE.Mesh(meshGeometry, meshMaterial);
            droneGroup.add(droneFrustumMesh);
            
            // Hide initially
            droneGroup.visible = false;
        }

        async function updateDronePosition() {
            try {
                const response = await fetch(DRONE_API);
                if (!response.ok) return;

                const data = await response.json();
                if (!data || !data.position) return;

                // Apply 180Â° Z-rotation to match the splat scene transformation
                // x' = -x, y' = -y, z' = z
                dronePosition = new THREE.Vector3(-data.position[0], -data.position[1], data.position[2]);

                // Rotation:
                // The API gives a 3x3 rotation matrix (flat array)
                // We need to convert this to a Quaternion and apply the Z-180 rotation
                const m = new THREE.Matrix4();
                const R = data.rotation;
                // Set 3x3 part of 4x4 matrix
                m.set(
                    R[0], R[1], R[2], 0,
                    R[3], R[4], R[5], 0,
                    R[6], R[7], R[8], 0,
                    0,    0,    0,    1
                );
                
                // Create rotation quaternion from matrix
                const q = new THREE.Quaternion();
                q.setFromRotationMatrix(m);

                // Apply Z-180 rotation: q_new = q_z180 * q
                // q_z180 is [0, 0, 1, 0]
                const q_z180 = new THREE.Quaternion(0, 0, 1, 0);
                q.premultiply(q_z180); // Apply world transform

                droneRotation = q;
                droneSource = data.source;
                numSplats = data.total_matches || 0; // Just using this field for info if needed

                // Update Info
                const info = document.getElementById('info');
                info.innerHTML = 
                    `Drone: [${data.position[0].toFixed(2)}, ${data.position[1].toFixed(2)}, ${data.position[2].toFixed(2)}]<br>` +
                    `Source: <span style="color:${data.source === 'hloc' ? '#00ff88' : '#ffa500'}">${data.source?.toUpperCase() || 'N/A'}</span> | ` +
                    `Mode: ${cameraMode === 'auto' ? 'Auto-Follow' : 'Free Camera'}`;

            } catch (error) {
                // console.error(error);
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            if (dronePosition && droneRotation && droneGroup) {
                // Update Drone Object
                droneGroup.visible = true;
                droneGroup.position.copy(dronePosition);
                droneGroup.quaternion.copy(droneRotation);

                // Update Color based on source
                const color = droneSource === 'hloc' ? 0x00ff88 : 0xffa500;
                if (droneFrustumLines.material.color.getHex() !== color) {
                    droneFrustumLines.material.color.setHex(color);
                    droneFrustumMesh.material.color.setHex(color);
                }

                // Auto-Follow Camera
                if (cameraMode === 'auto' && viewer && viewer.camera) {
                    // Calculate target camera position
                    // Behind and above the drone
                    const offset = new THREE.Vector3(0, CAMERA_OFFSET_UP, -CAMERA_OFFSET_BACK); // Local offset
                    offset.applyQuaternion(droneRotation); // Rotate to world
                    offset.add(dronePosition); // Add to position

                    // Smoothly interpolate camera position
                    viewer.camera.position.lerp(offset, CAMERA_LERP_SPEED);
                    
                    // Look at drone
                    // We can't use lookAt directly with lerp easily for orientation, 
                    // but OrbitControls usually handles lookAt.
                    // If we modify camera directly, we might fight controls.
                    // GaussianSplats3D uses OrbitControls. We can update its target.
                    
                    if (viewer.controls) {
                        viewer.controls.target.lerp(dronePosition, CAMERA_LERP_SPEED);
                        viewer.controls.update();
                    } else {
                        viewer.camera.lookAt(dronePosition);
                    }
                }
            }
        }

        function handleMessage(event) {
            const data = event.data;
            if (data.type === 'setCameraMode') {
                cameraMode = data.mode;
                // If switching to manual, we might want to reset controls or something
                // But OrbitControls handles manual interaction naturally
            }
        }

        init();
    </script>
</body>
</html>
